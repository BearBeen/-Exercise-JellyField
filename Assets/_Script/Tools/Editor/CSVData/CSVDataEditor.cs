using CsvHelper;
using CsvHelper.Configuration;
using System.Collections.Generic;
using System.Globalization;
using System;
using System.IO;
using System.Text;
using UnityEngine;
using UnityEditor;

public static partial class CSVDataEditor
{
    private class CSVParserFieldInfo
    {
        public string FieldName;
        public string TypeString;
        public string CollumeName;
        public string CustomConverter;

        public void ExportCode(StringBuilder stringBuilder)
        {
            if (!string.IsNullOrEmpty(TypeString))
            {
                stringBuilder.Append(
$@"
    [SerializeField] private {TypeString} m_{FieldName};
    public {TypeString} {FieldName}
    {{
        get => m_{FieldName};
        private set
        {{
            m_{FieldName} = value;
        }}
    }}
"
                    );
            }
        }
    }

    private const int HEADER_LINE_COUNT = 5;
    private static readonly string _localizableMark = "Lz";
    private static readonly string _rawConfigPath = AssetConst.CreatPath(new string[] { Application.dataPath, "../Config" });
    private static readonly string _ingameConfigPath = AssetConst.CreatPath(new string[] { AssetConst.AssetRoot, "Config" });
    private static readonly string _configParserPath = AssetConst.CreatPath(new string[] { Application.dataPath, "_Script/Core/Manager/Config/Parser" });
    private static readonly string _codeGenMark = "//This file is auto generated by CSVDataEditor. All edit will be overrided when re-generating" + Environment.NewLine;

    public static void GenerateAllParser()
    {
        //detele all old data
        if (Directory.Exists(_configParserPath))
        {
            Directory.Delete(_configParserPath, true);
        }
        Directory.CreateDirectory(_configParserPath);
        //create all c# file for scriptableobject correctsponding to the csv data
        var config = new CsvConfiguration(CultureInfo.InvariantCulture)
        {
            HasHeaderRecord = true,
            MissingFieldFound = null,
        };

        CSVParserFieldInfo fieldInfo = null;
        List<CSVParserFieldInfo> fieldInfos = new List<CSVParserFieldInfo>();
        StringBuilder stringBuilder = new StringBuilder();
        List<string> fileNames = new List<string>();

        foreach (string filePath in Directory.GetFiles(_rawConfigPath, "*.csv", SearchOption.AllDirectories))
        {
            using (var reader = new StreamReader(filePath))
            using (var csv = new CsvReader(reader, config))
            {
                string fileName = Path.GetFileNameWithoutExtension(filePath);
                string structureBaseName = fileName.EndsWith(_localizableMark) ? "Localizable" : "ConfigStructure";
                fileNames.Add(fileName);
                fieldInfos.Clear();
                stringBuilder.Clear();
                stringBuilder.Append(_codeGenMark).Append(
$@"#if UNITY_EDITOR
using CsvHelper.Configuration;
using UnityEngine;
#endif
using System;
using System.Collections.Generic;

public class {fileName}: ConfigBase<{fileName}Structure>
{{
    public List<{fileName}Structure> Data = new List<{fileName}Structure>();

    protected override List<{fileName}Structure> GetData()
    {{
        return this.Data;
    }}
}}

[Serializable]
public class {fileName}Structure: {structureBaseName}
{{");

                for (int i = 0; i < HEADER_LINE_COUNT; i++)
                {
                    csv.Read();
                    int collumeIndex = 0;
                    string data = csv.GetField(collumeIndex);
                    while (data != null)
                    {
                        if (fieldInfos.Count <= collumeIndex)
                        {
                            fieldInfo = new CSVParserFieldInfo();
                            fieldInfos.Add(fieldInfo);
                        }
                        else
                        {
                            fieldInfo = fieldInfos[collumeIndex];
                        }

                        switch (i)
                        {
                            case 0:
                                fieldInfo.CollumeName = data;
                                break;
                            case 1:
                                fieldInfo.FieldName = data;
                                break;
                            case 2:
                                fieldInfo.TypeString = data;
                                break;
                            case 3:
                                fieldInfo.CustomConverter = data;
                                break;
                            case 4:
                                fieldInfo.ExportCode(stringBuilder);
                                break;
                        }

                        collumeIndex++;
                        data = csv.GetField(collumeIndex);
                    }
                }
                stringBuilder.Append(
$@"
}}

#if UNITY_EDITOR
public class {fileName}StructureMap : ClassMap<{fileName}Structure>
{{
    public {fileName}StructureMap()
    {{");
                for (int i = 0; i < fieldInfos.Count; i++)
                {
                    stringBuilder.Append(
$@"
        Map(m => m.{fieldInfos[i].FieldName}).Name(""{fieldInfos[i].CollumeName}"")");
                    if (!string.IsNullOrEmpty(fieldInfos[i].CustomConverter))
                    {
                        stringBuilder.Append($@".TypeConverter(new {fieldInfos[i].CustomConverter}())");
                    }
                    stringBuilder.Append(";");
                }
                stringBuilder.Append(
$@"
    }}
}}
#endif");
                //write config's class file
                using (StreamWriter writer = new StreamWriter(AssetConst.CreatPath(new string[] { _configParserPath, $"{fileName}.cs" })))
                {
                    writer.Write(stringBuilder.ToString());
                }
                //write config parser mapping
                using (StreamWriter writer = new StreamWriter(AssetConst.CreatPath(new string[] { CustomTools.EDITOR_TOOL_PATH, $"CSVData/CSVDataEditor_ParserMap.cs" })))
                {
                    stringBuilder.Clear();
                    stringBuilder.Append(_codeGenMark).Append(
$@"using CsvHelper;
using System;
using UnityEditor;
using UnityEngine;

public static partial class CSVDataEditor
{{
    private static void CSV2SO(CsvReader csv, string fileName)
    {{
        switch (fileName)
        {{");
                    for (int i = 0; i < fileNames.Count; i++)
                    {
                        fileName = fileNames[i];
                        stringBuilder.Append(
$@"
            case ""{fileName}"":
                csv.Context.RegisterClassMap<{fileName}StructureMap>();
                {fileName} cfg_{fileName} = ScriptableObject.CreateInstance<{fileName}>(); ;
                SkipHeader(csv);
                while (csv.Read())
                {{
                    cfg_{fileName}.Data.Add(csv.GetRecord<{fileName}Structure>());
                }}
                AssetDatabase.CreateAsset(cfg_{fileName}, AssetConst.CreatPath(new string[] {{ _ingameConfigPath, $""{fileName}.asset"" }}));
                break;");
                }
                stringBuilder.Append(
$@"
        }}
    }}
}}
");
                    writer.Write(stringBuilder.ToString());
                }
            }
        }
        AssetDatabase.Refresh();
        Debug.Log("All parsers and mapper are created");
    }

    public static void GenerateAllIngameData()
    {
        try
        {
            AssetDatabase.DisallowAutoRefresh();
            //detele all old data
            string ingameDataFolderPath = AssetConst.CreatPath(new string[] { Application.dataPath, "Config" });
            if (Directory.Exists(ingameDataFolderPath))
            {
                Directory.Delete(ingameDataFolderPath, true);
            }
            Directory.CreateDirectory(ingameDataFolderPath);
            //create all scriptableobject correctsponding to the csv data
            var config = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = false,
                MissingFieldFound = null,
                IncludePrivateMembers = true,
            };

            foreach (string filePath in Directory.GetFiles(_rawConfigPath, "*.csv", SearchOption.AllDirectories))
            {
                using (var reader = new StreamReader(filePath))
                using (var csv = new CsvReader(reader, config))
                {
                    string fileName = Path.GetFileNameWithoutExtension(filePath);
                    CSV2SO(csv, fileName);
                }
            }

            Debug.Log("Ingame data generate complete");
        }
        catch (Exception exception)
        {
            Debug.LogError(exception + exception.StackTrace);
        }
        finally
        {
            AssetDatabase.AllowAutoRefresh();
            AssetDatabase.Refresh();
        }
    }

    private static void SkipHeader(CsvReader reader)
    {
        for (int i = 0; i < HEADER_LINE_COUNT; i++)
        {
            reader.Read();
        }
    }
}
